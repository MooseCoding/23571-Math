import numpy as np
import math
import os

# ---------- Configuration ----------
class_name = "Aimbot"
output_path = f"{class_name}.java"   # writes to current directory; change as needed

# numeric scan parameters (match your previous script)
k_start = 6.0 # Minumum distance you want to shoot from
k_end = 204.0 # Maximum distance you want to shoot from
k_step = 0.5 # Step size

y_min = 750.0 # Your flywheel minimum value
y_max = 2000.0 # Your flywheel maximum value

def solve_for_x(k, y):
    a = -283.3333 # Your A value from the equation
    b = 98.7865 + 0.1838 * y # Your B value from the equation
    c = -200.1912 + 0.3383 * y - 0.0001 * y * y - k # Your C value from the equation

    disc = b * b - 4.0 * a * c
    if disc < 0:
        return None
    sqrt_disc = math.sqrt(disc)
    x1 = (-b + sqrt_disc) / (2.0 * a)
    x2 = (-b - sqrt_disc) / (2.0 * a)

    # Return the first finite root (mimics your original logic)
    for x in (x1, x2):
        if math.isfinite(x):
            return x
    return None








# formatting helpers
def fmt_val(v):
    """Format value for Java source with 3 decimals, or Double.NaN if not finite."""
    if not np.isfinite(v):
        return "Double.NaN"
    # Ensure we always use a decimal point (e.g. 0.039 -> 0.039)
    return f"{v:.3f}"

# ---------- Generate points ----------
k_values = np.arange(k_start, k_end + 1e-9, k_step)  # include k_end
y_scan = np.linspace(y_min, y_max, 1000)

points = []
for k in k_values:
    found = False
    for y in y_scan:
        x = solve_for_x(k, y)
        if x is not None:
            points.append((round(x, 3), round(y, 3)))
            found = True
            break
    if not found:
        points.append((float('nan'), float('nan')))

# ---------- Build Java source ----------
java_lines = []

java_lines.append("/**")
java_lines.append(" * Auto-generated Aimbot lookup table.")
java_lines.append(" * Generated by generate_aimbot_java.py")
java_lines.append(" *")
java_lines.append(" * Each entry: { x, y } where x and y are rounded to 3 decimal places.")
java_lines.append(" */")
java_lines.append(f"public class {class_name} " + "{")
java_lines.append("")
java_lines.append("    /**")
java_lines.append("     * Lookup table generated from numeric scan.")
java_lines.append("     */")
java_lines.append("    public static final double[][] points = {")
# Add rows
for (x, y) in points:
    xv = fmt_val(x)
    yv = fmt_val(y)
    java_lines.append(f"        {{ {xv}, {yv} }},")
java_lines.append("    };")
java_lines.append("")
java_lines.append("    // Linear interpolation between low and high (both are length-2 arrays: {hood, flywheel})")
java_lines.append("    public static double[] lerp(double t, double[] low, double[] high) {")
java_lines.append("        double hood = low[0] + t * (high[0] - low[0]);")
java_lines.append("        double flywheel = low[1] + t * (high[1] - low[1]);")
java_lines.append("        return new double[] { hood, flywheel };")
java_lines.append("    }")
java_lines.append("")
java_lines.append("    // Get interpolated values for a (possibly fractional) index 'distance', using fixed step size from Python")
java_lines.append("    // If out of bounds, clamps to valid range and returns the endpoint.")
java_lines.append(f"    public static double[] getValues(double distance) {{")
java_lines.append(f"        double k_step = {k_step};")  # inject Python variable here
java_lines.append("        if (Double.isNaN(distance) || k_step <= 0.0) {")
java_lines.append("            return new double[] { Double.NaN, Double.NaN };")
java_lines.append("        }")
java_lines.append("        int n = points.length;")
java_lines.append("        if (n == 0) {")
java_lines.append("            return new double[] { Double.NaN, Double.NaN };")
java_lines.append("        }")
java_lines.append("        int low = (int) Math.floor(distance / k_step);")
java_lines.append("        int high = (int) Math.ceil(distance / k_step);")
java_lines.append("        low = Math.max(0, Math.min(low, n - 1));")
java_lines.append("        high = Math.max(0, Math.min(high, n - 1));")
java_lines.append("        if (high == low) {")
java_lines.append("            return new double[] { points[low][0], points[low][1] };")
java_lines.append("        }")
java_lines.append("        double t = (distance - low * k_step) / k_step;")
java_lines.append("        return lerp(t, points[low], points[high]);")
java_lines.append("    }")
java_lines.append("")
java_lines.append("    // Prevent instantiation")
java_lines.append(f"    private {class_name}() {{}}")
java_lines.append("}")
java_source = "\n".join(java_lines)

# ---------- Write file ----------
with open(output_path, "w", newline="\n") as f:
    f.write(java_source)

print(f"Wrote Java class to: {os.path.abspath(output_path)}")
print(f"Rows written: {len(points)}")
